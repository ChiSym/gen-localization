;; # ProbComp Localization Tutorial
;;
;; This notebook aims to give an introduction to probabilistic
;; computation (ProbComp). This term refers to a way of expressing probabilistic
;; constructs in a computational paradigm, made precise by a probablistic
;; programming language (PPL). The programmer can thus encode their
;; probabilistic intuition for solving a problem into an algorithm. Back-end
;; language work automates the routine but error-prone derivations.

(ns lectures.intro
  (:refer-clojure
   :exclude [+ - * / = zero? compare abs
             numerator denominator ref partial infinite?])
  (:require [clojure.data.json :as json]
            [clojure.java.io :as java.io]
            [emmy.env :refer :all]))

;; ## The "real world"
;;
;; We assume given
;;
;; * a map of a space, together with
;; * some clutters that sometimes unexpectedly exist in that space.
;;
;; We also assume given a description of a robot's behavior via
;;
;; * an estimated initial pose (= position + heading), and
;; * a program of controls (= advance distance, followed by rotate heading).
;;
;; _In addition to the uncertainty in the initial pose, we are uncertain about
;; the true execution of the motion of the robot._
;;
;; Below, we will also introduce sensors.
;;
;;
;; ### Load map and robot data
;;
;; Generally speaking, we keep general code and specific examples in separate
;; cells, as signposted here.

(defn norm [v]
  (abs v))

;; TODO try malle?
;;
;; TODO defrecord?

(defn segment
  "Generates a segment from pose `p1` to pose `p2`."
  ([p1 p2]
   (segment p1 p2 (- p2 p1)))
  ([p1 p2 dp]
   {:p1 p1
    :p2 p2
    :dp dp}))

(def pv (principal-value Math/PI))

(defn pose
  ([p heading-or-dp]
   (if (vector? heading-or-dp)
     (let [[dx dy :as dp] heading-or-dp]
       (pose p (atan dy dx) dp))
     (pose p
           (pv heading-or-dp)
           [(cos heading-or-dp)
            (sin heading-or-dp)])))
  ([p hd dp]
   {:p p :hd hd :dp dp}))

(defn step-along-pose
  "Returns a new position by moving `s` units in the direction in which pose `p`
  is oriented."
  [p s]
  (+ (:p p) (* s (:dp p))))

(defn rotate-pose
  "Returns a new pose generated by rotating the existing pose `p` by `a` radians."
  [p a]
  (pose (:p p) (+ (:hd p) a)))

;; TODO multimethod?

(defn poses->segment [p1 p2]
  (pose (:p p1) (:p p2)))

;; A value `c :: Control` corresponds to the robot *first* advancing in its
;; present direction by `(:ds c)`, *then* rotating by `(:dhd c)`.

(defn control [ds dhd]
  {:ds ds :dhd dhd})

(defn create-segments
  ([verts]
   (create-segments verts false))
  ([verts loop-around?]
   (let [segs (into []
                    (map (fn [[p1 p2]]
                           (segment p1 p2)))
                    (partition 2 1 verts))]
     (if loop-around?
       (conj segs (segment
                   (:p2 (peek segs))
                   (:p1 (first segs))))
       segs))))

(create-segments [[0 0] [0 1] [1 2] [3 4]])

(defn load-world
  "TODO describe and tidy!"
  [data]
  (let [walls-vec      (:wall_verts data)
        walls          (create-segments walls-vec)
        clutters-vec   (:clutter_vert_groups data)
        clutters       (map create-segments clutters-vec)
        walls-clutters (into walls clutters)
        start          (let [{:keys [p hd]} (:start_pose data)]
                         (pose p hd))
        controls       (into []
                             (map (fn [{:keys [ds dhd]}]
                                    (control ds dhd)))
                             (:program_controls data))
        all-points     (->> (into walls-vec cat (conj clutters-vec [(:p start)])))
        [x-min x-max y-min y-max :as bounding-box]
        (reduce (fn [[x-min x-max y-min y-max] [x y]]
                  [(min x x-min)
                   (max x x-max)
                   (min y y-min)
                   (max y y-max)])
                [0 0 0 0]
                all-points)

        box-size (apply max (map (fn [[x y]]
                                   (max (- x-min x) (- x x-max) (- y-min y) (- y y-max)))
                                 all-points))
        center-point   [(double (/ (+ x-min x-max) 2.0)) (double (/ (+ y-min y-max) 2.0))]
        T              (count controls)]
    {:world
     {:walls          walls
      :clutters       clutters
      :walls-clutters walls-clutters
      :bounding-box   bounding-box
      :box-size       box-size
      :center-point   center-point}
     :robot-inputs
     {:start    start
      :controls controls}
     :T T}))

(defn path->data [filename]
  (-> (slurp
       (java.io/resource filename))
      (json/read-str :key-fn keyword)))

(defn path->world
  ([]
   (path->world "example_20_program.json"))
  ([filename]
   (load-world
    (path->data filename))))

(path->world)

;; ### Integrate a path from a starting pose and controls

;; If the motion of the robot is determined in an ideal manner by the controls,
;; then we may simply integrate to determine the resulting path. Na√Øvely, this
;; results in the following.

(defn apply-control
  "Applies the control to the given pose."
  [{:keys [p hd dp]} {:keys [ds dhd]}]
  (pose (+ p (* ds dp))
        (+ hd dhd)))

(defn integrate-controls-unphysical
  "Takes a `:robot-inputs` entry and returns a sequence of poses."
  [{:keys [start controls]}]
  (reductions apply-control start controls))

;; This code has the problem that it is **unphysical**: the walls in no way
;; constrain the robot motion.
;;
;; We employ the following simple physics: when the robot's forward step through
;; a control comes into contact with a wall, that step is interrupted and the
;; robot instead "bounces" a fixed distance from the point of contact in the
;; normal direction to the wall.

;; %%
;; Return unique s, t such that p + s*u == q + t*v.
;; function solve_lines(p :: Vector{Float64}, u :: Vector{Float64}, q :: Vector{Float64}, v :: Vector{Float64}; PARALLEL_TOL=1.0e-10)
;;     det = u[1] * v[2] - u[2] * v[1]
;;     if abs(det) < PARALLEL_TOL
;;         return nothing, nothing
;;     else
;;         s = (v[1] * (p[2]-q[2]) - v[2] * (p[1]-q[1])) / det
;;         t = (u[2] * (q[1]-p[1]) - u[1] * (q[2]-p[2])) / det
;;         return s, t
;;     end
;; end

;; function distance(p :: Pose, seg :: Segment) :: Float64
;;     s, t = solve_lines(p.p, p.dp, seg.p1, seg.dp)
;;     Solving failed (including, by fiat, if pose is parallel to segment) iff isnothing(s).
;;     Pose is oriented away from segment iff s < 0.
;;     Point of intersection lies on segment (as opposed to the infinite line) iff 0 <= t <= 1.
;;     return (isnothing(s) || s < 0. || !(0. <= t <= 1.)) ? Inf : s
;; end

;; """
;; Assumes
;; * `world_inputs` contains fields: `walls`, `bounce`
;; """
;; function physical_step(p1 :: Vector{Float64}, p2 :: Vector{Float64}, hd :: Float64, world_inputs :: NamedTuple) :: Pose
;;     step_pose = Pose(p1, p2 - p1)
;;     (s, i) = findmin(w -> distance(step_pose, w), world_inputs.walls)
;;     if s > norm(p2 - p1)
;;         Step succeeds without contact with walls.
;;         return Pose(p2, hd)
;;     else
;;         contact_point = p1 + s * step_pose.dp
;;         unit_tangent = world_inputs.walls[i].dp / norm(world_inputs.walls[i].dp)
;;         unit_normal = [-unit_tangent[2], unit_tangent[1]]
;;         Sign of 2D cross product determines orientation of bounce.
;;         if step_pose.dp[1] * world_inputs.walls[i].dp[2] - step_pose.dp[2] * world_inputs.walls[i].dp[1] < 0.
;;             unit_normal = -unit_normal
;;         end
;;         return Pose(contact_point + world_inputs.bounce * unit_normal, hd)
;;     end
;; end

;; """
;; Assumes
;; * `robot_inputs` contains fields: `start`, `controls`
;; * `world_inputs` contains fields: `walls`, `bounce`
;; """
;; function integrate_controls(robot_inputs :: NamedTuple, world_inputs :: NamedTuple)
;;     path = Vector{Pose}(undef, length(robot_inputs.controls) + 1)
;;     path[1] = robot_inputs.start
;;     for t in 1:length(robot_inputs.controls)
;;         p = path[t].p + robot_inputs.controls[t].ds * path[t].dp
;;         hd = path[t].hd + robot_inputs.controls[t].dhd
;;         path[t+1] = physical_step(path[t].p, p, hd, world_inputs)
;;     end
;;     return path
;; end;


;; How bouncy the walls are in this world.
;; world_inputs = (walls = world.walls, bounce = 0.1)

;; path_integrated = integrate_controls(robot_inputs, world_inputs);
